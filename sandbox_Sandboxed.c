/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <cheri/cheri.h>
#include <stdio.h>

struct cheri_object test;

#define assert(v) \
	do { \
	if (!(v)) { \
		printf("assertion failed: %s:%s:%d " #v "\n", __FILE__, __func__, __LINE__); \
		__builtin_trap(); \
	}} while(0)

/* Header for class sandbox_Sandboxed */

void print_cap(const void *c)
{
	printf("b:0x%llx l:0x%llx o:0x%llx t:%d s:%d\n",
			(unsigned long long)__builtin_memcap_base_get(c),
			(unsigned long long)__builtin_memcap_length_get(c),
			(unsigned long long)__builtin_memcap_offset_get(c),
			(int)__builtin_memcap_type_get(c),
			(int)__builtin_memcap_sealed_get(c));
}

/*
 * Class:     sandbox_Sandboxed
 * Method:    nativeThing
 * Signature: ()I
 */

JNIEXPORT jint JNICALL Java_Sandboxed_nativeThing
  (JNIEnv *env, jobject this) {
	static int counter = 42;
	return counter++;
}

/*
 * Class:     sandbox_Sandboxed
 * Method:    nativeThingWithArgs
 * Signature: (Ljava/lang/Object;IJ)V
 */
JNIEXPORT void JNICALL Java_Sandboxed_nativeThingWithArgs
  (JNIEnv *env, jobject this, jobject obj, jint anInt, jlong aLong)
{
	assert(__builtin_memcap_sealed_get(this));
	assert(__builtin_memcap_sealed_get(obj));
	assert(!__builtin_memcap_sealed_get(env));
	assert(anInt == 1);
	assert(aLong == 2);
	assert(0x10006 == (*env)->GetVersion(env));
}

JNIEXPORT void JNICALL Java_Sandboxed_leakArray
  (JNIEnv *env, jobject this, jintArray array)
{
	static jint *buffer;
	static jobject *leakobject;
	assert(buffer == 0);
	assert(leakobject == 0);
	leakobject = this;
	jboolean isCopy;
	assert(__builtin_memcap_sealed_get(array));
	buffer = (*env)->GetIntArrayElements(env, array, &isCopy);
	assert(isCopy == 0);
	assert(!__builtin_memcap_sealed_get(buffer));
	assert(__builtin_memcap_length_get(buffer) == sizeof(jint) * 10);
	long long perms = __builtin_memcap_perms_get(buffer);
	assert((perms & __CHERI_CAP_PERMISSION_PERMIT_STORE_CAPABILITY__) == 0);
	assert((perms & __CHERI_CAP_PERMISSION_PERMIT_LOAD_CAPABILITY__) == 0);
	buffer = __builtin_memcap_bounds_set(buffer + 3, 4);
	(*env)->ReleaseIntArrayElements(env, array, buffer, 0);
}

JNIEXPORT void JNICALL Java_Sandboxed_arrayaccess
  (JNIEnv *env, jobject this, jintArray array)
{
	jboolean isCopy;
	assert(__builtin_memcap_sealed_get(array));
	jint *buffer = (*env)->GetIntArrayElements(env, array, &isCopy);
	assert(!__builtin_memcap_sealed_get(buffer));
	assert(__builtin_memcap_length_get(buffer) == sizeof(jint) * 10);
	long long perms = __builtin_memcap_perms_get(buffer);
	assert((perms & __CHERI_CAP_PERMISSION_PERMIT_STORE_CAPABILITY__) == 0);
	assert((perms & __CHERI_CAP_PERMISSION_PERMIT_LOAD_CAPABILITY__) == 0);
}

JNIEXPORT void JNICALL Java_Sandboxed_invalidarrayaccess
  (JNIEnv *env, jobject this, jintArray array)
{
	jboolean isCopy;
	assert(__builtin_memcap_sealed_get(array));
	jint *buffer = (*env)->GetIntArrayElements(env, array, &isCopy);
	assert(isCopy == 0);
	buffer[10] = 12;
}

JNIEXPORT void JNICALL Java_Sandboxed_nativeTrap
  (JNIEnv *env, jobject this)
{
}

JNIEXPORT void JNICALL Java_Sandboxed_reflectfields
  (JNIEnv *env, jobject this, jobject r)
{
	jclass cls = (*env)->GetObjectClass(env, r);
	assert(__builtin_memcap_sealed_get(cls));
	jfieldID f = (*env)->GetFieldID(env, cls, "x", "I");
	assert(__builtin_memcap_sealed_get(f));
	jint x = (*env)->GetIntField(env, r, f);
	assert(x == 12);
	(*env)->SetIntField(env, r, f, -1);
	f = (*env)->GetFieldID(env, cls, "y", "J");
	assert(__builtin_memcap_sealed_get(f));
	jlong y = (*env)->GetLongField(env, r, f);
	assert(y == 42);
	(*env)->SetLongField(env, r, f, 47);
}

JNIEXPORT void JNICALL Java_Sandboxed_reflectabuse
  (JNIEnv *env, jobject this, jobject r)
{
	jclass cls = (*env)->GetObjectClass(env, r);
	jfieldID f = (*env)->GetFieldID(env, cls, "x", "I");
	(*env)->SetIntField(env, r, (jfieldID)cls, -1);
}

JNIEXPORT void JNICALL Java_Sandboxed_callbackintA
  (JNIEnv *env, jobject this, jobject m)
{
	jclass cls = (*env)->GetObjectClass(env, m);
	jmethodID id = (*env)->GetMethodID(env, cls, "accumulate", "(II)I");
	static jvalue args[2];
	args[0].i = 12;
	args[1].i = 5;
	int result = (*env)->CallIntMethodA(env, m, id, args);
	assert(result == 60);
	args[0].i = 16;
	args[1].i = 4;
	result = (*env)->CallIntMethodA(env, m, id, args);
	assert(result == 124);
}

JNIEXPORT jint JNICALL Java_Sandboxed_00024NativeState_count
  (JNIEnv *env, jobject this)
{
	static int x=1;
	return x++;
}


__attribute__((cheri_ccall))
int invoke(void)
{
	return (-1);
}

